# -*- coding: utf-8 -*-
"""Quantum Cryptography Project (Ιmplementing BB84).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dMEzZ4sYzl24bvySt-HuWgn5O4fapYOV

# **Ιmplementing BB84 Project**
---

<br>

### **Project Structure**
**Part 1**: [Listing and using the Tools](#p1)

**Part 2**: [Implementing BB84 in Python](#p2)
>
> **Part 2.1**: [The Protocol](#p2.1)
>
> **Part 2.2**: [Modifying the Protocol](#p2.2)

<br>

<br>

### **Resources**
* [BB84 Cheat Sheet](https://docs.google.com/document/d/1FTBVWQsRVPvuP5e4lo3D62F0NOyfA1qIIPrDnocV6nc/edit)

<br>

**Before starting, run the code below to import all necessary functions and libraries.**
"""

!pip install cirq --quiet
import cirq

from random import choices

"""<a name="p1"></a>

---
## **Part 1: Listing and using the Tools**
---

#### **Problem #1.1**

Use the `choices(...)` function to create a list of 5 elements that are `'Alice'`, `'Bob'`, or `'Eve'`.

##### **Solution**
"""

choices(['Alice', 'Bob', 'Eve'], k = 5)

"""#### **Problem #1.2**

Use the `choices(...)` function to create a list of 15 elements that are the ints `0`, `1`, or `2`.

##### **Solution**
"""

choices([0, 1, 2], k = 15)

"""#### **Problem #1.3**

Create a dictionary called `my_gates` with key, value pairs as follows:
* `'do nothing'`: `cirq.I`.
* `'flip bit'`: `cirq.X`.
* `'flip phase'`: `cirq.Z`.
* `'superposition'`: `cirq.H`.


<br>

At the end, print the `superposition` gate.

##### **Solution**
"""

my_gates = {'do nothing': cirq.I, 'flip bit': cirq.X, 'flip phase': cirq.Z, 'superposition': cirq.H}

my_gates['superposition']

"""#### **Problem #1.4**

Complete the code below to apply each gate in `gates_list` to `qubit`.

##### **Solution**
"""

qubit = cirq.NamedQubit('q0')
circuit = cirq.Circuit()

gates_list = [cirq.X, cirq.I, cirq.Z, cirq.H]

for i in range(4):
  circuit.append(gates_list[i](qubit))

print(circuit)

"""#### **Problem #1.5**

Complete the code below to:
* Store 20 randomly chosen gates in `gates_list`.
* Apply each of the gates in `gates_list` to `qubit`.

##### **Solution**
"""

qubit = cirq.NamedQubit('q0')
circuit = cirq.Circuit()

gates_list = choices([cirq.X, cirq.I, cirq.Z, cirq.H], k = 20)

for i in range(20):
  circuit.append(gates_list[i](qubit))

print(circuit)

"""#### **Problem #1.6**

Complete the code below to:
* Store 50 (`num_bits`) randomly chosen numbers from `[0, 1, 2]` in `gates_list`.
* Apply the `i`th gate in `gates_list` to the `i`th qubit using `gates_dict` to determine which gate to use from numbers `[0, 1, 2]`.

##### **Solution**
"""

num_bits = 50
qubits = cirq.NamedQubit.range(num_bits, prefix = 'q')
circuit = cirq.Circuit()

gates_list = choices([0, 1, 2], k = num_bits)
gates_dict = {0: cirq.I, 1: cirq.X, 2: cirq.H}

for i in range(num_bits):

  gate_num = gates_list[i]
  gate = gates_dict[gate_num]
  qubit = qubits[i]
  circuit.append(gate(qubit))

print(circuit)

"""<a name="p2.1"></a>

---
### **Part 2.1: The Protocol**
---

The entire BB84 protocol between Alice and Bob is implemented below.

#### **The Setup**
"""

encode_gates = {0: cirq.I, 1: cirq.X}
basis_gates = {'Z': cirq.I, 'X': cirq.H}

num_bits = 5
qubits = cirq.NamedQubit.range(num_bits, prefix = 'q')

"""#### **Phase #1: Alice Sends**"""

# Step #1
alice_key = choices([0, 1], k = num_bits)

print('Alice\'s initial key: ', alice_key)

# Step #2
alice_bases = choices(['Z', 'X'], k = num_bits)

print('\nAlice\'s randomly chosen bases: ', alice_bases)

# Step #3
alice_circuit = cirq.Circuit()

for bit in range(num_bits):

  encode_value = alice_key[bit]
  encode_gate = encode_gates[encode_value]

  basis_value = alice_bases[bit]
  basis_gate = basis_gates[basis_value]

  qubit = qubits[bit]
  alice_circuit.append(encode_gate(qubit))
  alice_circuit.append(basis_gate(qubit))

print('\nAlice\'s Phase 1 circuit:\n', alice_circuit)

"""#### **Phase #2: Bob Receives**"""

# Step #4
# No code required for this Step


# Step #5
bob_bases = choices(['Z', 'X'], k = num_bits)
print('Bob\'s randomly chosen bases: ', bob_bases)

bob_circuit = cirq.Circuit()

for bit in range(num_bits):

  basis_value = bob_bases[bit]
  basis_gate = basis_gates[basis_value]

  qubit = qubits[bit]
  bob_circuit.append(basis_gate(qubit))


# Step #6
bob_circuit.append(cirq.measure(qubits, key = 'bob key'))

print('\nBob\'s Phase 2 circuit:\n', bob_circuit)


# Step #7
bb84_circuit = alice_circuit + bob_circuit

sim = cirq.Simulator()
results = sim.run(bb84_circuit)
bob_key = results.measurements['bob key'][0]

print('\nBob\'s initial key: ', bob_key)

"""#### **Phase #3: Alice and Bob Compare**"""

# Step #8
final_alice_key = []
final_bob_key = []

for bit in range(num_bits):

  if alice_bases[bit] == bob_bases[bit]:
    final_alice_key.append(alice_key[bit])
    final_bob_key.append(bob_key[bit])

print('\nAlice\'s key: ', final_alice_key)
print('Bob\'s key: ', final_bob_key)


# Step #9
if final_alice_key[0] == final_bob_key[0]:
  final_alice_key = final_alice_key[1:]
  final_bob_key = final_bob_key[1:]

  print('\n\nWe can use our keys!')
  print('Alice Key: ', final_alice_key)
  print('Bob Key: ', final_bob_key)

else:
  print('\n\nEve was listening, we need to use a different channel!')

"""<a name="p2.2"></a>

---
### **Part 2.2: Modifying the Protocol**
---

#### **Problem #2.1**

The BB84 protocol instructs Alice to encode the bits of her key into qubits as 0s and 1s first and then encode them into the Z or X bases.

<br>

**Modify the code in Phase #1 so that Alice encodes her qubits in the opposite order, in other words into the Z or X bases *before* encoding the bits of her key as 0s or 1s.**

<br>

##### **Solution**

This is the resulting code. It just requires the last two lines in the loop to be swapped.
"""

# Step #1
alice_key = choices([0, 1], k = num_bits)

print('Alice\'s initial key: ', alice_key)

# Step #2
alice_bases = choices(['Z', 'X'], k = num_bits)

print('\nAlice\'s randomly chosen bases: ', alice_bases)

# Step #3
alice_circuit = cirq.Circuit()

for bit in range(num_bits):

  encode_value = alice_key[bit]
  encode_gate = encode_gates[encode_value]

  basis_value = alice_bases[bit]
  basis_gate = basis_gates[basis_value]

  qubit = qubits[bit]
  alice_circuit.append(basis_gate(qubit))
  alice_circuit.append(encode_gate(qubit))

print('\nAlice\'s Phase 1 circuit:\n', alice_circuit)

"""#### **Problem #2.2**

<br>

**Modify the code in Phase #2 so that Bob's steps are appended to `alice_circuit` instead of creating a new circuit.**

<br>

##### **Solution**

This is the resulting code. The parts that need to be removed have been commented out so that you can more easily compare these two versions.
"""

# Step #4
# No code required for this Step


# Step #5
bob_bases = choices(['Z', 'X'], k = num_bits)
print('Bob\'s randomly chosen bases: ', bob_bases)

# bob_circuit = cirq.Circuit()

for bit in range(num_bits):

  basis_value = bob_bases[bit]
  basis_gate = basis_gates[basis_value]

  qubit = qubits[bit]
  #bob_circuit.append(basis_gate(qubit))
  alice_circuit.append(basis_gate(qubit))


# Step #6
#bob_circuit.append(cirq.measure(qubits, key = 'bob key'))
alice_circuit.append(cirq.measure(qubits, key = 'bob key'))

#print('\nBob\'s Phase 2 circuit:\n', bob_circuit)


# Step #7
bb84_circuit = alice_circuit# + bob_circuit

sim = cirq.Simulator()
results = sim.run(bb84_circuit)
bob_key = results.measurements['bob key'][0]

print('\nBob\'s initial key: ', bob_key)

"""#### **Problem #2.3**
<br>

**Modify the code in Phase #3 so that Alice and Bob compare the first two bits instead of just one.**

##### **Solution**
"""

# Step #8
final_alice_key = []
final_bob_key = []

for bit in range(num_bits):

  if alice_bases[bit] == bob_bases[bit]:
    final_alice_key.append(alice_key[bit])
    final_bob_key.append(bob_key[bit])

print('\nAlice\'s key: ', final_alice_key)
print('Bob\'s key: ', final_bob_key)


# Step #9
if final_alice_key[0:2] == final_bob_key[0:2]:
  final_alice_key = final_alice_key[2:]
  final_bob_key = final_bob_key[2:]

  print('\n\nWe can use our keys!')
  print('Alice Key: ', final_alice_key)
  print('Bob Key: ', final_bob_key)

else:
  print('\n\nEve was listening, we need to use a different channel!')

"""---
© 2023 The Coding School Project
"""